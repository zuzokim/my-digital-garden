---
{"dg-publish":true,"permalink":"/posts/react-feat/","tags":["Browser","React"],"created":"2025-02-23","updated":"2025-02-23T18:18:00"}
---

최근 무한스크롤을 React로 구현하다가 만난 문제를 해결하면서 브라우저 렌더링 사이클에 관해 공부한 내용 정리입니다.

## 요구사항 : 무한스크롤 구현하기 - 카드목록UI를 스크롤할 때마다 20개씩 더 보여주기

요구사항을 구현하기 위해 아래 4가지 단계가 필요합니다.

1. 스크롤 감지
2. 스크롤 감지후 목록 데이터 추가 요청하기
3. 기존 목록 데이터와 합치기
4. **목록 데이터를 추가로 가져온 뒤에도 기존의 스크롤하던 위치 유지하기**

일단 첫번째 **스크롤 감지** 를 위해서 아래 2가지 방법이 떠올랐고

1. scroll 이벤트를 이벤트리스너로 구독해 현재 스크롤 위치를 받아옵니다.
2. IntersectionObserver를 이용해 detect할 엘리먼트를 구독하고 해당 엘리먼트가 뷰포트에 들어오는지 감지합니다.

그중 IntersectionObserver를 활용해 목록 데이터를 추가로 가져와 기존 목록 데이터와 합쳐주는 것까지는 완성!

그러나 목록 state가 업데이트될 때마다 화면이 리렌더링되면서 **스크롤 위치가 최상단으로 리셋되어버리는 문제가 발생**했습니다. 유저 입장에서 스크롤하던 위치에서 데이터만 아래로 더 불러오는게 아니라 스크롤이 위로 쭉 끌어당겨지니 불편합니다. 다시 보던 위치까지 스크롤을 내려줘야 하니까요. **목록 데이터를 추가로 가져온 뒤에도 기존의 스크롤하던 위치를 유지** 하도록 해보겠습니다. 

기존 코드의 동작순서를 적어보면 이렇습니다.

1. 새로운 목록 데이터 fetching 완료
2. 상태(state) 업데이트 (list 배열에 새 데이터 추가)
3. React 컴포넌트 **리렌더링** 시작 
4. DOM 업데이트

React 라이프사이클에 따라 state 변경시 해당 state를 사용하는 List 컴포넌트가 리렌더링되면서 스크롤이 최상단으로 리셋됩니다. 따라서 스크롤 위치를 이동시켜주는 코드를 추가합니다.

1. 새로운 목록 데이터 fetching 완료
2. 상태(state) 업데이트 (list 배열에 새 데이터 추가)
3.  **window.scrollTo(기존 스크롤 위치) 실행** <- 추가
4. React 컴포넌트 리렌더링 시작 
5. DOM 업데이트

그러나 이 경우에도 문제는 해결이 되지 않았는데, 그 이유는 **window.scrollTo(기존 스크롤 위치)** 가 실행되는 시점이 실제 DOM이 업데이트 되기 전인 경우 제대로된 스크롤 위치를 찾을 수 없기 때문이었습니다.

좀 더 React의 상태 업데이트와 브라우저 렌더링 사이클 관점에서 설명해보겠습니다.

 1 . **React Render Phase**
   - **상태(state) 업데이트** : list 배열에 새로 fetching한 data merge
   - **Virtual DOM 생성** : 새로 업데이트된 list만큼 React children 엘리먼트 생성 
   - 이전과 이후의 **Virtual DOM diff 비교** -> 최소한의 DOM 업데이트 계획 수립
2 . **React Commit Phase**
   - **실제 DOM 업데이트** : 새로운 React children 엘리먼트가 추가되면서 새로운 DOM 노드 생성(or 수정/삭제)
   - refs 업데이트
3 . **브라우저 렌더링** 사이클
   - **Layout 업데이트(Reflow)** : 변경된 엘리먼트의 위치, 크기 계산
   - **Paint 페인팅** : 변경된 레이아웃 위에 픽셀 렌더링 (색상, 그림자, 테두리 등등 시각적 요소)
   - **Composite** : 최종 화면 구성

이런 순서를 바탕으로 작성한 코드의 실행 시점을 대입해보면 아래와 같습니다. (수도코드입니다.)

```
loadMore = () => {
	// API 요청
	fetching({
		//API 응답 후 실행되는 콜백
		onCompleted: () => {
		// 동기적으로 실행됨
		window.scrollTo({
			top: currentScrollPosition.current,
			behavior: 'auto' 
		})
		// 1. React Render Phase
		// - list 상태 업데이트 
		// - Virtual DOM 업데이트
		// - Diff 계산
		
		// 2. React Commit Phase
		// - 실제 DOM에 새로운 ListItem 추가
		
		// 3. 브라우저 렌더링 사이클
		// - Style: 새로운 ListItem 스타일 계산
		// - Layout: 페이지 레이아웃 재계산
		// - Paint: 새로운 콘텐츠 그리기
		// - Composite: 최종 화면 구성
		}
	});
};
```

실행 시점:
1. API 응답 수신 (비동기)
2. onCompleted 콜백 실행 (동기)
3. scrollTo 실행 (동기)
4. React 상태 업데이트 (동기적 호출, React 내부에서 비동기적 batch처리, 마이크로태스크 큐에서 처리)
5. React 렌더링 (render phase, commit phase, 마이크로태스크 큐에서 처리)
6. 브라우저 렌더링 (렌더링 큐에서 처리, 비동기)

onCompleted 콜백에서 window.scrollTo 는 React의 상태 업데이트나 브라우저 렌더링을 "**기다리지 않고**" 즉시 실행됩니다. 그렇기 때문에 새로운 list 데이터를 불러오고 난 뒤라도 **DOM을 모두 업데이트하기 전**, 즉 레이아웃 하단에 구독하고 있던 intersecting ref의 위치가 미처 계산되기 전 스크롤을 이동하게 되므로, 정확한 위치로 스크롤을 이동시킬 수 없게 되는 것입니다.


그러면 정확히 
1. 새로운 list 데이터를 가져오고
2. React 상태를 업데이트하고
3. React 렌더링 과정을 거쳐
4. 브라우저 렌더링을 마치고 난 뒤
를 기다렸다가 스크롤 위치를 이동해주려면 어떻게 해야할까요?


setTimeout을 활용하여 이 모든 순서를 기다려 실행 순서를 보장할 수 있습니다.

```
onCompleted : () => {
	setTimeout(() => {
		window.scrollTo({
			top: currentScrollPosition.current,
			behavior: "auto",
		});
	}, 20);
}
```

setTimeout을 이용해 콜백을 매크로태스크 큐로 보내고 실행순서를 보장할 수 있습니다. 이렇게 무한스크롤시 새로운 데이터를 불러오고, 스크롤 위치도 기존에 보여주던 위치로 고정해 보여줄 수 있게 됐습니다.


### 마이크로태스크 큐 vs 매크로태스크 큐 어떻게 다른건데?

| 비교        | **매크로태스크 큐 (Macro Task Queue)**                                                                   | **마이크로태스크 큐 (Micro Task Queue)**                                                                  |     |
| --------- | ------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------- | --- |
| **정의**    | 실행이 끝난 후 **이벤트 루프가 다음 틱(Iteration)에서 실행할 작업**이 들어가는 큐                                             | **현재 실행 중인 스크립트가 끝나면 즉시 실행**되는 작업이 들어가는 큐                                                         |     |
| **주요 예시** | `setTimeout`, `setInterval`, `setImmediate(Node.js)` , `requestAnimationFrame`, `I/O작업`, `UI 렌더링` | `Promise callbacks (then,catch,finally)`, `MutationObserver`, `queueMicrotask()`, `React 상태 업데이트` |     |
| **실행 순서** | **이벤트 루프의 한 사이클(틱)마다 하나씩 실행**                                                                     | **매크로태스크 실행 후, 남은 마이크로태스크를 모두 실행**                                                                |     |
| **우선순위**  | 마이크로태스크보다 낮음                                                                                      | 매크로태스크보다 높음                                                                                       |     |
| **동작 방식** | 1. 실행 중인 콜 스택이 비면, 매크로태스크 큐에서 하나 가져와 실행.  <br>2. 실행된 매크로태스크가 새로운 마이크로태스크를 생성할 수도 있음.              | 1. 매크로태스크 실행 후 **모든 마이크로태스크를 실행**한 다음, 다음 매크로태스크로 넘어감.                                            |     |

예시 코드를 보면 실행 순서를 더 잘 알 수 있습니다.

```js

console.log('1'); // 동기 코드

Promise.resolve().then(() => {
	console.log('2'); // Micro Task Queue
});

setTimeout(() => {
	console.log('3'); // Macro Task Queue
}, 0);

console.log('4'); // 동기 코드


// 출력 순서: 1 -> 4 -> 2 -> 3
```

|**요소**|**설명**|
|---|---|
|**📌 콜 스택 (Call Stack)**|실행 중인 **동기 코드**(함수, 연산 등)가 쌓이는 공간|
|**📌 태스크 큐 (Task Queue, Job Queue)**|실행 대기 중인 **비동기 코드의 콜백 함수**가 들어가는 큐|
|**📌 이벤트 루프 (Event Loop)**|콜 스택이 비면, 태스크 큐에서 작업을 가져와 실행|

즉, **이벤트 루프**는 "콜 스택이 비었는지" 계속 확인하며, 비어 있으면 큐에 있는 작업을 실행합니다. 위의 예시코드를 설명해보면 아래와 같습니다.

1.  `console.log("1")` 콜 스택에서 실행 → **출력: `1`**  
2.  `Promise` 콜 스택에 등록 후 제거 → 마이크로태스크 큐로 이동
3. `setTimeout` 콜 스택에 등록 후 제거 → 매크로태스크 큐로 이동
4. `console.log("4")` 콜 스택에서 실행 → **출력: `4`**
5. 마이크로태스크 큐에 있는 `console.log("2")` 실행 → **출력: `2`**  **매크로태스크보다 마이크로태스크가 먼저 실행!**
6. 매크로태스트 큐에 있는 `console.log("3")` 실행 → **출력: `3

